import numpy as np

FR = np.array([25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 
                1.0, 1.250, 1.600, 2.000, 2.500, 3.150, 4.000, 5.000, 6.300, 8.000, 10.000, 12.500])

RAP = np.array([45, 55, 65, 71, 80, 90, 100, 120])

DLL = np.array([[-32, -24, -16, -10, -5, 0, -7, -3, 0, -2, 0],
                [-29, -22, -15, -10, -4, 0, -7, -2, 0, -2, 0],
                [-27, -19, -14, -9, -4, 0, -6, -2, 0, -2, 0],
                [-25, -17, -12, -9, -3, 0, -5, -2, 0, -2, 0],
                [-23, -16, -11, -7, -3, 0, -4, -1, 0, -1, 0],
                [-20, -14, -10, -6, -3, 0, -4, -1, 0, -1, 0],
                [-18, -12, -9, -6, -2, 0, -3, -1, 0, -1, 0],
                [-15, -10, -8, -4, -2, 0, -3, -1, 0, -1, 0]]).T

LTQ = np.array([30, 18, 12, 8, 7, 6, 5, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])

AO = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.5, -1.6, -3.2, -5.4, -5.6, -4.0, 
                -1.5, 2.0, 5.0, 12.0])

DDF = np.array([0, 0, 0.5, 0.9, 1.2, 1.6, 2.3, 2.8, 3.0, 2.0, 0.0, -1.4, -2.0, 
                -1.9, -1.0, 0.5, 3.0, 4.0, 4.3, 4.0])

DCB = np.array([-0.25, -0.6, -0.8, -0.8, -0.5, 0.0, 0.5, 1.1, 1.5, 1.7, 1.8, 1.8, 
                1.7, 1.6, 1.4, 1.2, 0.8, 0.5, 0.0, -0.5])

ZUP = np.array([0.9, 1.8, 2.8, 3.5, 4.4, 5.4, 6.6, 7.9, 9.2, 10.6, 12.3, 13.8, 15.2, 
                16.7, 18.1, 19.3, 20.6, 21.8, 22.7, 23.6, 24.0])

RNS = np.array([21.5, 18.0, 15.1, 11.5, 9.0, 6.1, 4.4, 3.1, 2.13, 1.36, 0.82, 0.42, 
                0.30, 0.22, 0.15, 0.10, 0.035, 0.0])

USL = np.array([[13.00, 8.20, 6.30, 5.50, 5.50, 5.50, 5.50, 5.50],
                [9.00, 7.50, 6.00, 5.10, 4.50, 4.50, 4.50, 4.50],
                [7.80, 6.70, 5.60, 4.90, 4.40, 3.90, 3.90, 3.90],
                [6.20, 5.40, 4.60, 4.00, 3.50, 3.20, 3.20, 3.20],
                [4.50, 3.80, 3.60, 3.20, 2.90, 2.70, 2.70, 2.70],
                [3.70, 3.00, 2.80, 2.35, 2.20, 2.20, 2.20, 2.20],
                [2.90, 2.30, 2.10, 1.90, 1.80, 1.70, 1.70, 1.70],
                [2.40, 1.70, 1.50, 1.35, 1.30, 1.30, 1.30, 1.30],
                [1.95, 1.45, 1.30, 1.15, 1.10, 1.10, 1.10, 1.10],
                [1.50, 1.20, 0.94, 0.86, 0.82, 0.82, 0.82, 0.82],
                [0.72, 0.67, 0.64, 0.63, 0.62, 0.62, 0.62, 0.62],
                [0.59, 0.53, 0.51, 0.50, 0.42, 0.42, 0.42, 0.42],
                [0.40, 0.33, 0.26, 0.24, 0.22, 0.22, 0.22, 0.22],
                [0.27, 0.21, 0.20, 0.18, 0.17, 0.17, 0.17, 0.17],
                [0.16, 0.15, 0.14, 0.12, 0.11, 0.11, 0.11, 0.11],
                [0.12, 0.11, 0.10, 0.08, 0.08, 0.08, 0.08, 0.08],
                [0.09, 0.08, 0.07, 0.06, 0.06, 0.06, 0.06, 0.05],
                [0.06, 0.05, 0.03, 0.02, 0.02, 0.02, 0.02, 0.02]])

def DIN45631(LT, MS):
    TI = np.zeros(11)
    for I in range(11):
        J = 0
        while J < 8:
            if LT[I] <= RAP[J] - DLL[I, J]:
                XP = LT[I] + DLL[I, J]
                TI[I] = 10 ** (0.1 * XP)
                J = 9  # To exit from the while loop
            else:
                J += 1
    if len(TI) < 11:
        print(' ')
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        print('WARNING!!!! ERROR!!!!! One of the 1/3 OBs level exceeded the metrics range.')
        print('If you are using this code to normalize loudness, reduce the initial level and try again.')
        print('Otherwise any results if obtained will be incorrect.')
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        print(' ')
        N = -1
        NS = -1 * np.ones(240)
        err = -1
        return N, NS, err
    GI = np.zeros(3)
    GI[0] = np.sum(TI[:6])
    GI[1] = np.sum(TI[6:9])
    GI[2] = np.sum(TI[9:11])

    LCB = np.zeros(3)
    for I in range(3):
        if GI[I] > 0:
            LCB[I] = 10 * np.log10(GI[I])

    LE = np.zeros(20)
    NM = np.zeros(21)
    for I in range(20):
        LE[I] = LT[I + 8]
        if I < 3:
            LE[I] = LCB[I]
        LE[I] = LE[I] - AO[I]
        if MS in ['d', 'D']:
            LE[I] = LE[I] + DDF[I]
        if LE[I] > LTQ[I]:
            LE[I] = LE[I] - DCB[I]
            S = 0.25
            MP1 = 0.0635 * 10 ** (0.025 * LTQ[I])
            MP2 = (1 - S + S * 10 ** (0.1 * (LE[I] - LTQ[I]))) ** 0.25 - 1
            NM[I] = MP1 * MP2
            if NM[I] <= 0:
                NM[I] = 0

    NM[20] = 0

    KORRY = 0.4 + 0.32 * NM[0] ** 0.2
    if KORRY > 1:
        KORRY = 1
    NM[0] = NM[0] * KORRY
    N = 0
    Z1 = 0
    N1 = 0
    IZ = 0
    Z = 0.1
    NS = np.zeros(240)

    for I in range(21):
        ZUP[I] = ZUP[I] + 0.0001
        IG = I
        if IG > 7:
            IG = 7
        while Z1 < ZUP[I]:
            if N1 > NM[I]:
                N2 = RNS[J]
                if N2 < NM[I]:
                    N2 = NM[I]
                DZ = (N1 - N2) / USL[J, IG]
                Z2 = Z1 + DZ
                if Z2 > ZUP[I]:
                    Z2 = ZUP[I]
                    DZ = Z2 - Z1
                    N2 = N1 - DZ * USL[J, IG]
                N = N + DZ * (N1 + N2) / 2
                while Z < Z2:
                    NS[IZ] = N1 - (Z - Z1) * USL[J, IG]
                    IZ += 1
                    Z += 0.1
            elif N1 == NM[I]:
                Z2 = ZUP[I]
                N2 = NM[I]
                N = N + N2 * (Z2 - Z1)
                while Z < Z2:
                    NS[IZ] = N2
                    IZ += 1
                    Z += 0.1
            else:
                for J in range(18):
                    if RNS[J] < NM[I]:
                        break
                Z2 = ZUP[I]
                N2 = NM[I]
                N = N + N2 * (Z2 - Z1)
                while Z < Z2:
                    NS[IZ] = N2
                    IZ += 1
                    Z += 0.1
            while J < 18:
                if N2 <= RNS[J]:
                    J += 1
                else:
                    break
            if N2 <= RNS[J] and J >= 18:
                J = 18
            Z1 = Z2
            N1 = N2
            
    if N < 0:
        N = 0
    elif N <= 16:
        N = np.floor(N * 1000 + 0.5) / 1000
    else:
        N = np.floor(N * 100 + 0.5) / 100

    err = 0
    return N, NS, err